// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"AndroidToolServer-Go/model"
)

func newApArticle(db *gorm.DB, opts ...gen.DOOption) apArticle {
	_apArticle := apArticle{}

	_apArticle.apArticleDo.UseDB(db, opts...)
	_apArticle.apArticleDo.UseModel(&model.ApArticle{})

	tableName := _apArticle.apArticleDo.TableName()
	_apArticle.ALL = field.NewAsterisk(tableName)
	_apArticle.ID = field.NewInt64(tableName, "id")
	_apArticle.Title = field.NewString(tableName, "title")
	_apArticle.AuthorID = field.NewInt32(tableName, "author_id")
	_apArticle.AuthorName = field.NewString(tableName, "author_name")
	_apArticle.ChannelID = field.NewInt32(tableName, "channel_id")
	_apArticle.ChannelName = field.NewString(tableName, "channel_name")
	_apArticle.Layout = field.NewInt32(tableName, "layout")
	_apArticle.Flag = field.NewInt32(tableName, "flag")
	_apArticle.Images = field.NewString(tableName, "images")
	_apArticle.Labels = field.NewString(tableName, "labels")
	_apArticle.Likes = field.NewInt32(tableName, "likes")
	_apArticle.Collection = field.NewInt32(tableName, "collection")
	_apArticle.Comment = field.NewInt32(tableName, "comment")
	_apArticle.Views = field.NewInt32(tableName, "views")
	_apArticle.ProvinceID = field.NewInt32(tableName, "province_id")
	_apArticle.CityID = field.NewInt32(tableName, "city_id")
	_apArticle.CountyID = field.NewInt32(tableName, "county_id")
	_apArticle.CreatedTime = field.NewTime(tableName, "created_time")
	_apArticle.PublishTime = field.NewTime(tableName, "publish_time")
	_apArticle.SyncStatus = field.NewBool(tableName, "sync_status")
	_apArticle.Origin = field.NewInt32(tableName, "origin")
	_apArticle.StaticURL = field.NewString(tableName, "static_url")

	_apArticle.fillFieldMap()

	return _apArticle
}

// apArticle 文章信息表，存储已发布的文章
type apArticle struct {
	apArticleDo

	ALL         field.Asterisk
	ID          field.Int64
	Title       field.String // 标题
	AuthorID    field.Int32  // 文章作者的ID
	AuthorName  field.String // 作者昵称
	ChannelID   field.Int32  // 文章所属频道ID
	ChannelName field.String // 频道名称
	/*
		文章布局
		            0 无图文章
		            1 单图文章
		            2 多图文章
	*/
	Layout field.Int32
	/*
		文章标记
		            0 普通文章
		            1 热点文章
		            2 置顶文章
		            3 精品文章
		            4 大V 文章
	*/
	Flag field.Int32
	/*
		文章图片
		            多张逗号分隔
	*/
	Images      field.String
	Labels      field.String // 文章标签最多3个 逗号分隔
	Likes       field.Int32  // 点赞数量
	Collection  field.Int32  // 收藏数量
	Comment     field.Int32  // 评论数量
	Views       field.Int32  // 阅读数量
	ProvinceID  field.Int32  // 省市
	CityID      field.Int32  // 市区
	CountyID    field.Int32  // 区县
	CreatedTime field.Time   // 创建时间
	PublishTime field.Time   // 发布时间
	SyncStatus  field.Bool   // 同步状态
	Origin      field.Int32  // 来源
	StaticURL   field.String

	fieldMap map[string]field.Expr
}

func (a apArticle) Table(newTableName string) *apArticle {
	a.apArticleDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a apArticle) As(alias string) *apArticle {
	a.apArticleDo.DO = *(a.apArticleDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *apArticle) updateTableName(table string) *apArticle {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.Title = field.NewString(table, "title")
	a.AuthorID = field.NewInt32(table, "author_id")
	a.AuthorName = field.NewString(table, "author_name")
	a.ChannelID = field.NewInt32(table, "channel_id")
	a.ChannelName = field.NewString(table, "channel_name")
	a.Layout = field.NewInt32(table, "layout")
	a.Flag = field.NewInt32(table, "flag")
	a.Images = field.NewString(table, "images")
	a.Labels = field.NewString(table, "labels")
	a.Likes = field.NewInt32(table, "likes")
	a.Collection = field.NewInt32(table, "collection")
	a.Comment = field.NewInt32(table, "comment")
	a.Views = field.NewInt32(table, "views")
	a.ProvinceID = field.NewInt32(table, "province_id")
	a.CityID = field.NewInt32(table, "city_id")
	a.CountyID = field.NewInt32(table, "county_id")
	a.CreatedTime = field.NewTime(table, "created_time")
	a.PublishTime = field.NewTime(table, "publish_time")
	a.SyncStatus = field.NewBool(table, "sync_status")
	a.Origin = field.NewInt32(table, "origin")
	a.StaticURL = field.NewString(table, "static_url")

	a.fillFieldMap()

	return a
}

func (a *apArticle) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *apArticle) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 22)
	a.fieldMap["id"] = a.ID
	a.fieldMap["title"] = a.Title
	a.fieldMap["author_id"] = a.AuthorID
	a.fieldMap["author_name"] = a.AuthorName
	a.fieldMap["channel_id"] = a.ChannelID
	a.fieldMap["channel_name"] = a.ChannelName
	a.fieldMap["layout"] = a.Layout
	a.fieldMap["flag"] = a.Flag
	a.fieldMap["images"] = a.Images
	a.fieldMap["labels"] = a.Labels
	a.fieldMap["likes"] = a.Likes
	a.fieldMap["collection"] = a.Collection
	a.fieldMap["comment"] = a.Comment
	a.fieldMap["views"] = a.Views
	a.fieldMap["province_id"] = a.ProvinceID
	a.fieldMap["city_id"] = a.CityID
	a.fieldMap["county_id"] = a.CountyID
	a.fieldMap["created_time"] = a.CreatedTime
	a.fieldMap["publish_time"] = a.PublishTime
	a.fieldMap["sync_status"] = a.SyncStatus
	a.fieldMap["origin"] = a.Origin
	a.fieldMap["static_url"] = a.StaticURL
}

func (a apArticle) clone(db *gorm.DB) apArticle {
	a.apArticleDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a apArticle) replaceDB(db *gorm.DB) apArticle {
	a.apArticleDo.ReplaceDB(db)
	return a
}

type apArticleDo struct{ gen.DO }

func (a apArticleDo) Debug() *apArticleDo {
	return a.withDO(a.DO.Debug())
}

func (a apArticleDo) WithContext(ctx context.Context) *apArticleDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a apArticleDo) ReadDB() *apArticleDo {
	return a.Clauses(dbresolver.Read)
}

func (a apArticleDo) WriteDB() *apArticleDo {
	return a.Clauses(dbresolver.Write)
}

func (a apArticleDo) Session(config *gorm.Session) *apArticleDo {
	return a.withDO(a.DO.Session(config))
}

func (a apArticleDo) Clauses(conds ...clause.Expression) *apArticleDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a apArticleDo) Returning(value interface{}, columns ...string) *apArticleDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a apArticleDo) Not(conds ...gen.Condition) *apArticleDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a apArticleDo) Or(conds ...gen.Condition) *apArticleDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a apArticleDo) Select(conds ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a apArticleDo) Where(conds ...gen.Condition) *apArticleDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a apArticleDo) Order(conds ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a apArticleDo) Distinct(cols ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a apArticleDo) Omit(cols ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a apArticleDo) Join(table schema.Tabler, on ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a apArticleDo) LeftJoin(table schema.Tabler, on ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a apArticleDo) RightJoin(table schema.Tabler, on ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a apArticleDo) Group(cols ...field.Expr) *apArticleDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a apArticleDo) Having(conds ...gen.Condition) *apArticleDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a apArticleDo) Limit(limit int) *apArticleDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a apArticleDo) Offset(offset int) *apArticleDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a apArticleDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *apArticleDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a apArticleDo) Unscoped() *apArticleDo {
	return a.withDO(a.DO.Unscoped())
}

func (a apArticleDo) Create(values ...*model.ApArticle) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a apArticleDo) CreateInBatches(values []*model.ApArticle, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a apArticleDo) Save(values ...*model.ApArticle) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a apArticleDo) First() (*model.ApArticle, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApArticle), nil
	}
}

func (a apArticleDo) Take() (*model.ApArticle, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApArticle), nil
	}
}

func (a apArticleDo) Last() (*model.ApArticle, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApArticle), nil
	}
}

func (a apArticleDo) Find() ([]*model.ApArticle, error) {
	result, err := a.DO.Find()
	return result.([]*model.ApArticle), err
}

func (a apArticleDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ApArticle, err error) {
	buf := make([]*model.ApArticle, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a apArticleDo) FindInBatches(result *[]*model.ApArticle, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a apArticleDo) Attrs(attrs ...field.AssignExpr) *apArticleDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a apArticleDo) Assign(attrs ...field.AssignExpr) *apArticleDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a apArticleDo) Joins(fields ...field.RelationField) *apArticleDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a apArticleDo) Preload(fields ...field.RelationField) *apArticleDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a apArticleDo) FirstOrInit() (*model.ApArticle, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApArticle), nil
	}
}

func (a apArticleDo) FirstOrCreate() (*model.ApArticle, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApArticle), nil
	}
}

func (a apArticleDo) FindByPage(offset int, limit int) (result []*model.ApArticle, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a apArticleDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a apArticleDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a apArticleDo) Delete(models ...*model.ApArticle) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *apArticleDo) withDO(do gen.Dao) *apArticleDo {
	a.DO = *do.(*gen.DO)
	return a
}
